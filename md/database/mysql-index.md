### mysql 索引相关
1. 为什么使用索引：索引是有序的，查询数据无需遍历，效率趋近于log2n
2. 索引分类
    1. hash：把键通过hash算法换算成hash值
        1. 劣势：
            1. 不支持范围查询
            2. 不知查询后排序
            3. 不支持联合查询最左匹配规则
        2. 优势：
            1. 没有大量重复元素的等值查询，如：select id from table where name = "**";
    2. b+树：平衡的多叉树，从根节点到每个叶子节点的高度相差不超过1.而且同层的指针相互连接，是有序的
    3. b-树和b+树的区别
        1. b-树每个节点都包含key，data，并且叶子节点指针为nul，不保存关键字信息(？？？没太懂)
        2. b+树的叶子节点都包含关键字信息，及指向这些关键字的指针，且叶子节点按照关键字大小自小而大的顺序链接。
    4. 为什么使用b+树，而不是b-树作为索引
        1. b+树的根节点不包含数据，每一次IO读取的索引数据更多
        2. b+树的查询效率稳定为log2n，b-树最好为O(1)
        
    
#### explain查看索引是否有效
- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
- select_type: SELECT 查询的类型.
- table: 查询的是哪个表
- partitions: 匹配的分区
- type: join 类型
- possible_keys: 此次查询中可能选用的索引
- key: 此次查询中确切使用到的索引.
- ref: 哪个字段或常数与 key 一起被使用
- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.
- filtered: 表示此查询条件所过滤的数据的百分比
- extra: 额外的信息
    
#### 索引失效条件
1. like查询以%开头
2. or查询左右2侧没有同时以索引作为查询条件
3. 组合索引， 不是使用第一列索引：复合索引存储是按照创建的顺序存储的，
4. 数据类型隐式转换，varchar不加引号时可能转换为int
5. 索引上使用is null ，is not null，不一定失效？？
6. not，<>, != 等操作符
7. 对索引字段进行计算，字段使用函数
8. mysql全表扫描比使用索引效率更高时

#### 什么时候不建或者少键索引
1. 表记录太少
2. 经常写入，更新，删除的表
3. 重复且分布平均的字段，如订单状态？
4. 经常和主字段一起查询，但主字段索引值比较多的字段？？？

#### 表分区
#### 事务相关
1. 四种隔离级别
- Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
- Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
- Read committed (读已提交)：可避免脏读的发生。
- Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
2. 事务特性
- 原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。
- 一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态
- 隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
- 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。
3. 并发控制
- LBCC：Lock-Based Concurrency Control，基于锁的并发控制
- MVCC：Multi-Version Concurrency Control：基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进。读不加锁，读写不冲突，主要是在读操作上提高了并发量。
    - 快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）
    - 当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录
4. MySQL默认情况下auto commit，不支持事务

#### 锁


        
#### 
   