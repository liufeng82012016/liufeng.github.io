### 算法
程序=数据结构+算法  +效率？
#### 概念
1. 基本性质
    1. 输入
    2. 输出
    3. 正确性
    4. 确定性：任一算法都可以描述为由基本操作组成的序列
    5. 可行性
    6. 有穷性
2. 好算法具有的特性
    1. 能处理简单的、大规模的、一般性的、退化的、任意合法的输入
    2. 健壮：能识别不合法的输入，并适当处理，而不至于异常推出
    3. 可读性：结构化+准确命名+注释
    4. 效率：速度尽可能快，消耗资源尽可能少
3. 算法成本：运行时间 + 使用的存储空间（因为空间成本持续走低，注意力被专注于运行时间）
4. 图灵机
5. Random Access Mechine
    1. 寄存器顺序编号，总数没有限制
    2. 每一个操作仅需要常数时间 -- 将运行时间转换为基本操作数量
6. 大O记号：最坏时间复杂度
7. Ω记号：最好时间复杂度
8. 平均复杂度：
9. 时间复杂度估算：循环和基数

#### 分类
1. 迭代和递归
2. 减而治之 
    1. 将问题拆分成2个子问题，一个是普通问题（结果直接获得），一个是规模缩小且相似的子问题
    2. 分别计算子问题的解，子问题不断缩小，缩小成一个普通问题（边界条件）
    3. 由子问题求得原问题的解
3. 分治
    1. 将一定规模的拆分成若干个（通常是2个）规模相当的子问题
    2. 分别计算子问题
    3. 由子问题求得原问题的解


#### 算法思路(排序算法按照升序排列)
1. 插入排序：
   1. 已知第一个元素是有序的； 
   2. 从第二个元素开始遍历，与有序序列相比较，插入到合适的位置；
   3. 每遍历一次，有序序列长度加1，最终全部有序；
2. 冒泡排序：
   1. 每次从第一个元素开始遍历，与它下一个元素相比，将较大值放在右侧；第一轮遍历之后，最大值归位到最右侧；
   2. 重复上一步，每一轮遍历后，无序序列的最大值排到有序序列的最左侧，有序序列长度加1，最终全部有序；
3. 选择排序
   1. 每次从第一个元素开始遍历，选出元素中的最大值，将最大值放在序列最右侧；
   2. 重复第一步，将次大值放在最大值左侧；
   3. 每一次遍历，右侧有序序列长度加1，最终全部有序；
4. 希尔排序
   1. 和快速排序类似，但不是依次遍历，间隔和数组长度有关，每次遍历间隔减小，最终间隔为1时，排序完成；
5. 归并排序
   1. 将数组拆分为2个子数组（递归，拆分到只有一个元素时，该数组有序），分别排序，最终按大小合并到一起；
6. 快速排序
   1. 选择1个元素P
   2. 将序列中大于P的元素移动到P的右侧，将序列中小于P的元素移动到P的左侧
   3. 重复1，2步骤，分别对P左侧的序列和P右侧的元素进行排序
   4. 当P左右2侧的元素有序后，整个序列有序
7. 基数排序
   1. 遍历元素，按照个位排序
   2. 取上一步排序完成的序列，按十位排序
   3. 百位，千位。。。直到数组元素最大的位数
   4. 按最后一次排序得到的序列取出元素
8. 计数排序
   1. 定义一个temp数组，长度为(max-min+1)，遍历，将数组元素element存入temp\[element]
   2. 遍历temp数组，取出不为0的元素，依次写入原数组
9. 桶排序
   1. 将数组元素拆分到m个桶（有序），分别排序
   2. 按照桶/桶内元素序列 2个排序合并序列
10. 堆排序
11. LIS：最长递增子序列
    1. 动态规划解法：
       1. 最短序列长度为1
       2. 假设第i个元素lis(i) = f(i);分为2种情况
          1. f(i)计算结果包含元素i ==> f(i) = f(i-1)+1
          2. f(i)计算结果不包含元素i ==> f(i)与f(i-1)无关，与f(i-2)有关 ==> 元素i遍历时，如果出现这种情况，忽略；向下遍历自动处理
    2. 缓存数组
       1. 定义一个缓存数组temp，用于缓存最小序列
       2. 如果arr\[i]>temp\[endIndex]，将arr\[i]追加到temp末尾；否则，从temp数组查找比arr\[i]大第一个元素，替换掉；
       3. 为什么是替换不是插入？题目要求递增，那么同样长度的子序列，靠前的同一索引处，值越小，那么后续元素有效（后续元素比该元素大）的可能性越大
12. LCS：最长公共子序列
    1. 动态规划解法
       1. 
    2. 转为LIS ![lcs-lis](../img/algo-LCS-LIS.png)
13. DP-斐波那契数列
