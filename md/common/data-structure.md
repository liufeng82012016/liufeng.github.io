### 概念
    1. 数据存储在内存时，决定了数据顺序和位置关系的就是数据结构
    2. 链表：数据线性存储在分散的空间，数据添加和删除都很方便，访问比较耗时。（因为数据分散存储，无法根据index直接获取地址）
        2.1 单向链表
        2.2 双向链表
        2.3 循环链表(可以用于保存固定长度数据)
        2.4 
    3. 数组：数据线性存储在连续空间，数据访问很快，但是修改消耗较大。
    4. 栈： 数据线性存储，但是只能访问最新的元素，就像箱子里的物品，永远只能先拿到顶部的一个（First in，last out.FILO）。栈是一种概念，可以有不同的实现
    5. 队列：数据线性存储，一端输入，一端输出。银行业务，先排队，先办理。（First in,first out）.队列同样是一种概念，可以有不同实现。
    6. 哈希表：由数组实现，它使用'哈希算法'对要查询的元素进行映射，然后固定存放在数据的某个格子里（更新后仍然在同一个格子）。
        6.1 每一格不一定是单个元素，也可以是一个链表。JDK1.8里，链表元素达到8个，就会变成红黑树，提高查询效率。
        6.2 哈希寻址的方法也有多种实现
            6.2.1 开放定址法：
            6.2.2 链定址法：
    7. 堆：是一种图形结构，被用于实现优先队列。优先队列是一种数据结构，可以自由添加数据，但取出数据需要从最小值按顺序取出。在堆的图形结构中，每个节点称为顶点（node），数据就存在这里。
        7.1 每个节点最多2个子节点，顺序从上到下，从左到右排列
        7.2 子节点必须大于父节点，最小值保存在根节点中。因此在添加数据时，遵循一个规则：一般会将新数据放到偏左的位置，如果没有剩余空间，将新启一行，将数据放在最左侧。
    8. 二叉查找树：又名二叉搜索树，二叉排序树，使用了图的树形结构。（不存在相同元素）
        8.1 每个节点最多2个子节点
        8.2 每个节点的值大于任意左侧子节点的值
        8.3 每个节点的值小于任意右侧子节点的值
    9. 图：由顶点和边组成。
        9.1 如果给边加一个值表示权重，这样的图成为加权图。加权图可以表示可以表示连接程度，否则只能表示连接状态。
        9.2 给边加上箭头，称为有向图（可以结合权重使用）。
        
        
### 排序算法
    1. 冒泡排序(n^2)：从序列右边开始比较2个相邻数据的大小，再根据结果交换2个数字的位置
    2. 选择排序(n^2)：从待排序的数据查找最小值，将其与序列最左边的值交换
    3. 插入排序(n^2)：从序列左端依次排序。排序过程中，左侧部分已排序，依次从未排序数据挑选合适的位置插入。
    4. 堆排序(nlogn)： 先把数据按顺序写入堆，然后依次取出
    5. 归并排序(nlogn)：将序列拆分成长度为一半的序列，直到无法拆分(只包含一个元素，并且已排好序)，然后每2个序列按顺序合并成一个，知道合成为1个。
    6. 快速排序(nlogn)：将序列拆分为基准值，大于基准值，小于基准值3部分（分治），大于/小于部分继续拆分(递归)，合并之后即是有序序列。

### 数组查找
    1. 线性查找(n)：按顺序依次查找
    2. 二分查找(logn)：只能查询已排序的数据。
    
### 图搜索(求最短距离)
    1. 广度优先搜索：假设一开始位于某个顶点作为起点，需要到达某个终点。此时并不知道图的结构，只能沿着最近的边搜索，直到终点。每到达一个顶点，都需要判断是否是终点。
    2. 深度优先搜索：沿着某条边直到边缘，如果没有查找到目标。折返换边继续
    3. 贝尔曼-福特算法：将起始点的值设为0，其他顶点的值设为无限大，每次扫描将顶点的值设为min(oldValue,newValue)，更新后的值就是最小值。假设n个顶点，m条边，扫描次数为nm。
    4. 狄克斯特拉算法：相对于贝尔曼-福特算法，多了一个选择顶点的方法。