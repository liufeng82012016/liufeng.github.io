<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
</head>
<body>
<div id="app"></div>
<!--  cd 指定目录-->
<!--  npm init vite-app vite-->
<!--  cd vite-->
<!--  npm install (or `yarn`)-->
<!--  npm run dev (or `yarn dev`)-->
<!--  public：公共静态文件-->
<!--  src：项目源代码-->
<!--    assets存放项目中所有的静态资源文件-->
<!--    components目录存放自定义组件-->
<!--    App.vue是项目的根组件-->
<!--    index.css是项目的全局样式表文件-->
<!--    main.js是整个项目的打包入口文件-->
<!--  index.html：项目中唯一的页面-->

<!--  组件开发指的是：根据封装的思想，把页面上可重复的部分封装成组件；-->
<!--  vue中组件的后缀名是.vue-->
<!--  组件组成：-->
<!--    template：模版结构，必须，就是html？-->
<!--    script-->
<!--    style-->
<!--  组件必须注册后才能使用，全局组件在所有组件中使用（main.js），局部注册在单个组件内可用（指定组件内注册即可），组件命名可以用短横线或大驼峰风格-->
<!--  但页面应用中，写在.vue组件中的样式会全局生效，容易造成多个组件之间的样式冲突问题，dom都属于index.html-->
<!--  解决方案1：为组件中所有标签添加自定义属性，通过属性选择器区分，vue在style节点添加scoped属性就会自动实现隔离，为了让属性生效，vue增加/deep/深度选择器-->

<!--  DOM结构、Style要尽量复用-->
<!--  组件中要展示的数据，尽量由组件的使用者提供-->
<!--  props：父组件通过props向子组件提供属性；props传入的值可以动态绑定-->

<!--  自定义事件：封装组件时，为了让组件的使用者可以监听到组件内状态的变化，需要用到自定义事件-->
<!--  1. 声明自定义事件-->
<!--  2. 触发-->
<!--  3. 监听 this.$emit('functionName')-->
<!--  父子组件数据双向绑定:父组件使用v-model传递props属性，子组件通过emit回传-->

<!--  组件高级特性：掌握watch侦听器基本使用，知道vue常用的生命周期函数，知道组件之间如何数据共享，知道vue3.x全局配置axios-->
<!--  计算属性侧重于监听多个值的变化，计算之后返回一个新值-->
<!--  监听起侧重于单个数据的变化，最终执行特定的逻辑-->
<!--  当组件的数据更新后，vue会更新view和model保持一致，这时候会触发update方法-->

<!--  组件之间的关系：父子关系、兄弟关系、后代关系-->
<!--  兄弟组件借助EventBus共享：借助于第三方的包mitt来创建eventBus对象，从而实现兄弟组件之间的数据共享；首先安装mitt包，期次初始化EventBus对象，然后由发送方通过自定义事件发送数据，最后接收方通过自定义事件获得数据-->
<!--  父子组件通过Provide方法对子孙组件共享，子孙节点使用inject接受-->

<!--ref:辅助开发者在不依赖jQuery的情况下，获取dom元素的引用；每个组件的示例上，都包含一个$refs对象，里面包含对dom元素或组件的引用，默认是一个空对象-->
<!--注意：当更新了数据后，vue会异步渲染，这时候获取dom会返回undifined，需要调用this.$nextTick(callback)方法延迟到dom渲染完之后执行-->
<!--动态切换组件：使用component标签；因为切换组件时组件会被销毁，keep-live保持组件状态-->
<!--插槽：为用户预留占位符；如果有多个，需要为slot标签设定name以区分，没有指定name，默认name=default；外部调用通过v-slot指令设定，简写#；-->
<!--作用域插槽：传入属性动态绑定props数据；-->
<!--自定义指令：私有、全局（main.js声明）-->

<!--路由：前端路由（hash地址（url上#后地址）与组件之间的对应关系）+后端路由（请求方式、请求地址和处理函数的对应关系）-->
<!--vue-router3.x配合vue2使用，vue-router4.x配合vue3使用-->
<!--vue-router4.x：
1-安装(npm install vue-router@next -D )
2-定义路由组件
3-声明路由链接和占位符（router-link声明路由链接，router-view声明路由占位符）
4-创建路由模块
    4.1 从vue-router导入2个方法
    4.2 导入需要使用路由控制的组件
    4.3 创建路由实例对象
    4.4 向外共享路由实例对象
    4.5 在main.js导入并挂载路由模块
-->
<!--动态路由：将hash地址中可变的部分定义为参数项，提高路由的复用性-->
<!--编程式导航：this.#route.push('hash'地址)，this.$route.go(step)可以实现前进和后退-->
<!--导航守卫：控制路由的访问权限-->

<script type="module" src="/src/main.js"></script>
</body>

</html>
